/* automatically generated by rust-bindgen */

pub const PD_MAJOR_VERSION: ::std::os::raw::c_uint = 0;
pub const PD_MINOR_VERSION: ::std::os::raw::c_uint = 47;
pub const PD_BUGFIX_VERSION: ::std::os::raw::c_uint = 1;
pub const PD_TEST_VERSION: &'static [u8; 1usize] = b"\x00";
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101204;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const MAXPDSTRING: ::std::os::raw::c_uint = 1000;
pub const MAXPDARG: ::std::os::raw::c_uint = 5;
pub const PD_FLOATSIZE: ::std::os::raw::c_uint = 32;
pub const GP_NONE: ::std::os::raw::c_uint = 0;
pub const GP_GLIST: ::std::os::raw::c_uint = 1;
pub const GP_ARRAY: ::std::os::raw::c_uint = 2;
pub const T_TEXT: ::std::os::raw::c_uint = 0;
pub const T_OBJECT: ::std::os::raw::c_uint = 1;
pub const T_MESSAGE: ::std::os::raw::c_uint = 2;
pub const T_ATOM: ::std::os::raw::c_uint = 3;
pub const CLASS_DEFAULT: ::std::os::raw::c_uint = 0;
pub const CLASS_PD: ::std::os::raw::c_uint = 1;
pub const CLASS_GOBJ: ::std::os::raw::c_uint = 2;
pub const CLASS_PATCHABLE: ::std::os::raw::c_uint = 3;
pub const CLASS_NOINLET: ::std::os::raw::c_uint = 8;
pub const CLASS_TYPEMASK: ::std::os::raw::c_uint = 3;
pub const MAXLOGSIG: ::std::os::raw::c_uint = 32;
pub const MAXSIGSIZE: ::std::os::raw::c_ulonglong = 4294967296;
pub const LOGCOSTABSIZE: ::std::os::raw::c_uint = 9;
pub const COSTABSIZE: ::std::os::raw::c_uint = 512;
extern "C" {
    #[link_name = "pd_compatibilitylevel"]
    pub static mut pd_compatibilitylevel: ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
pub type t_int = ::std::os::raw::c_long;
pub type t_float = f32;
pub type t_floatarg = f32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _symbol {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_thing: *mut *mut _class,
    pub s_next: *mut _symbol,
}
#[test]
fn bindgen_test_layout__symbol() {
    assert_eq!(::std::mem::size_of::<_symbol>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _symbol ) ));
    assert_eq! (::std::mem::align_of::<_symbol>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _symbol ) ) . s_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _symbol ) , "::" ,
                stringify ! ( s_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _symbol ) ) . s_thing as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _symbol ) , "::" ,
                stringify ! ( s_thing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _symbol ) ) . s_next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _symbol ) , "::" ,
                stringify ! ( s_next ) ));
}
impl Clone for _symbol {
    fn clone(&self) -> Self { *self }
}
pub type t_symbol = _symbol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _array {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct _gstub {
    pub gs_un: _gstub__bindgen_ty_1,
    pub gs_which: ::std::os::raw::c_int,
    pub gs_refcount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union _gstub__bindgen_ty_1 {
    pub gs_glist: *mut _glist,
    pub gs_array: *mut _array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gstub__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_gstub__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( _gstub__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_gstub__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _gstub__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gstub__bindgen_ty_1 ) ) . gs_glist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gstub__bindgen_ty_1 )
                , "::" , stringify ! ( gs_glist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gstub__bindgen_ty_1 ) ) . gs_array as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gstub__bindgen_ty_1 )
                , "::" , stringify ! ( gs_array ) ));
}
impl Clone for _gstub__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__gstub() {
    assert_eq!(::std::mem::size_of::<_gstub>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _gstub ) ));
    assert_eq! (::std::mem::align_of::<_gstub>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _gstub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gstub ) ) . gs_un as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gstub ) , "::" ,
                stringify ! ( gs_un ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gstub ) ) . gs_which as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _gstub ) , "::" ,
                stringify ! ( gs_which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gstub ) ) . gs_refcount as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _gstub ) , "::" ,
                stringify ! ( gs_refcount ) ));
}
impl Clone for _gstub {
    fn clone(&self) -> Self { *self }
}
pub type t_gstub = _gstub;
#[repr(C)]
#[derive(Copy)]
pub struct _gpointer {
    pub gp_un: _gpointer__bindgen_ty_1,
    pub gp_valid: ::std::os::raw::c_int,
    pub gp_stub: *mut t_gstub,
}
#[repr(C)]
#[derive(Copy)]
pub union _gpointer__bindgen_ty_1 {
    pub gp_scalar: *mut _scalar,
    pub gp_w: *mut word,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gpointer__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_gpointer__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _gpointer__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_gpointer__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _gpointer__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gpointer__bindgen_ty_1 ) ) . gp_scalar
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gpointer__bindgen_ty_1
                ) , "::" , stringify ! ( gp_scalar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gpointer__bindgen_ty_1 ) ) . gp_w as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gpointer__bindgen_ty_1
                ) , "::" , stringify ! ( gp_w ) ));
}
impl Clone for _gpointer__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__gpointer() {
    assert_eq!(::std::mem::size_of::<_gpointer>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _gpointer ) ));
    assert_eq! (::std::mem::align_of::<_gpointer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _gpointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gpointer ) ) . gp_un as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gpointer ) , "::" ,
                stringify ! ( gp_un ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gpointer ) ) . gp_valid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _gpointer ) , "::" ,
                stringify ! ( gp_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gpointer ) ) . gp_stub as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _gpointer ) , "::" ,
                stringify ! ( gp_stub ) ));
}
impl Clone for _gpointer {
    fn clone(&self) -> Self { *self }
}
pub type t_gpointer = _gpointer;
#[repr(C)]
#[derive(Copy)]
pub union word {
    pub w_float: t_float,
    pub w_symbol: *mut t_symbol,
    pub w_gpointer: *mut t_gpointer,
    pub w_array: *mut _array,
    pub w_binbuf: *mut _binbuf,
    pub w_index: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_word() {
    assert_eq!(::std::mem::size_of::<word>() , 8usize , concat ! (
               "Size of: " , stringify ! ( word ) ));
    assert_eq! (::std::mem::align_of::<word>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_float as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_float ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_symbol as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_gpointer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_gpointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_array as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_binbuf as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_binbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const word ) ) . w_index as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( word ) , "::" ,
                stringify ! ( w_index ) ));
}
impl Clone for word {
    fn clone(&self) -> Self { *self }
}
pub type t_word = word;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum t_atomtype {
    A_NULL = 0,
    A_FLOAT = 1,
    A_SYMBOL = 2,
    A_POINTER = 3,
    A_SEMI = 4,
    A_COMMA = 5,
    A_DEFFLOAT = 6,
    A_DEFSYM = 7,
    A_DOLLAR = 8,
    A_DOLLSYM = 9,
    A_GIMME = 10,
    A_CANT = 11,
}
#[repr(C)]
#[derive(Copy)]
pub struct _atom {
    pub a_type: t_atomtype,
    pub a_w: word,
}
#[test]
fn bindgen_test_layout__atom() {
    assert_eq!(::std::mem::size_of::<_atom>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _atom ) ));
    assert_eq! (::std::mem::align_of::<_atom>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _atom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atom ) ) . a_type as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _atom ) , "::" ,
                stringify ! ( a_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atom ) ) . a_w as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( _atom ) , "::" ,
                stringify ! ( a_w ) ));
}
impl Clone for _atom {
    fn clone(&self) -> Self { *self }
}
pub type t_atom = _atom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _outlet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _inlet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _binbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _clock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _outconnect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glist {
    _unused: [u8; 0],
}
pub type t_pd = *mut _class;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _gobj {
    pub g_pd: t_pd,
    pub g_next: *mut _gobj,
}
#[test]
fn bindgen_test_layout__gobj() {
    assert_eq!(::std::mem::size_of::<_gobj>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _gobj ) ));
    assert_eq! (::std::mem::align_of::<_gobj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _gobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gobj ) ) . g_pd as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gobj ) , "::" ,
                stringify ! ( g_pd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gobj ) ) . g_next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _gobj ) , "::" ,
                stringify ! ( g_next ) ));
}
impl Clone for _gobj {
    fn clone(&self) -> Self { *self }
}
pub type t_gobj = _gobj;
#[repr(C)]
#[derive(Copy)]
pub struct _scalar {
    pub sc_gobj: t_gobj,
    pub sc_template: *mut t_symbol,
    pub sc_vec: [t_word; 1usize],
}
#[test]
fn bindgen_test_layout__scalar() {
    assert_eq!(::std::mem::size_of::<_scalar>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _scalar ) ));
    assert_eq! (::std::mem::align_of::<_scalar>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _scalar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _scalar ) ) . sc_gobj as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _scalar ) , "::" ,
                stringify ! ( sc_gobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _scalar ) ) . sc_template as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _scalar ) , "::" ,
                stringify ! ( sc_template ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _scalar ) ) . sc_vec as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _scalar ) , "::" ,
                stringify ! ( sc_vec ) ));
}
impl Clone for _scalar {
    fn clone(&self) -> Self { *self }
}
pub type t_scalar = _scalar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _text {
    pub te_g: t_gobj,
    pub te_binbuf: *mut _binbuf,
    pub te_outlet: *mut _outlet,
    pub te_inlet: *mut _inlet,
    pub te_xpix: ::std::os::raw::c_short,
    pub te_ypix: ::std::os::raw::c_short,
    pub te_width: ::std::os::raw::c_short,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout__text() {
    assert_eq!(::std::mem::size_of::<_text>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _text ) ));
    assert_eq! (::std::mem::align_of::<_text>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_g as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_binbuf as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_binbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_outlet as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_outlet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_inlet as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_inlet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_xpix as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_xpix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_ypix as * const _ as usize
                } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_ypix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _text ) ) . te_width as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _text ) , "::" ,
                stringify ! ( te_width ) ));
}
impl Clone for _text {
    fn clone(&self) -> Self { *self }
}
impl _text {
    #[inline]
    pub fn te_type(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 3u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_te_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 3u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(te_type: ::std::os::raw::c_uint) -> u8 {
        ({ 0 } | ((te_type as u32 as u8) << 0usize) & (3u64 as u8))
    }
}
pub type t_text = _text;
pub type t_object = _text;
pub type t_method = ::std::option::Option<unsafe extern "C" fn()>;
pub type t_newmethod =
    ::std::option::Option<unsafe extern "C" fn()
                              -> *mut ::std::os::raw::c_void>;
pub type t_gotfn =
    ::std::option::Option<unsafe extern "C" fn(x:
                                                   *mut ::std::os::raw::c_void, ...)>;
extern "C" {
    #[link_name = "pd_objectmaker"]
    pub static mut pd_objectmaker: t_pd;
}
extern "C" {
    #[link_name = "pd_canvasmaker"]
    pub static mut pd_canvasmaker: t_pd;
}
extern "C" {
    #[link_name = "s_pointer"]
    pub static mut s_pointer: t_symbol;
}
extern "C" {
    #[link_name = "s_float"]
    pub static mut s_float: t_symbol;
}
extern "C" {
    #[link_name = "s_symbol"]
    pub static mut s_symbol: t_symbol;
}
extern "C" {
    #[link_name = "s_bang"]
    pub static mut s_bang: t_symbol;
}
extern "C" {
    #[link_name = "s_list"]
    pub static mut s_list: t_symbol;
}
extern "C" {
    #[link_name = "s_anything"]
    pub static mut s_anything: t_symbol;
}
extern "C" {
    #[link_name = "s_signal"]
    pub static mut s_signal: t_symbol;
}
extern "C" {
    #[link_name = "s__N"]
    pub static mut s__N: t_symbol;
}
extern "C" {
    #[link_name = "s__X"]
    pub static mut s__X: t_symbol;
}
extern "C" {
    #[link_name = "s_x"]
    pub static mut s_x: t_symbol;
}
extern "C" {
    #[link_name = "s_y"]
    pub static mut s_y: t_symbol;
}
extern "C" {
    #[link_name = "s_"]
    pub static mut s_: t_symbol;
}
extern "C" {
    pub fn pd_typedmess(x: *mut t_pd, s: *mut t_symbol,
                        argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn pd_forwardmess(x: *mut t_pd, argc: ::std::os::raw::c_int,
                          argv: *mut t_atom);
}
extern "C" {
    pub fn gensym(s: *const ::std::os::raw::c_char) -> *mut t_symbol;
}
extern "C" {
    pub fn getfn(x: *mut t_pd, s: *mut t_symbol) -> t_gotfn;
}
extern "C" {
    pub fn zgetfn(x: *mut t_pd, s: *mut t_symbol) -> t_gotfn;
}
extern "C" {
    pub fn nullfn();
}
extern "C" {
    pub fn pd_vmess(x: *mut t_pd, s: *mut t_symbol,
                    fmt: *mut ::std::os::raw::c_char, ...);
}
pub type t_gotfn1 =
    ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_void,
                                               arg1:
                                                   *mut ::std::os::raw::c_void)>;
pub type t_gotfn2 =
    ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_void,
                                               arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
pub type t_gotfn3 =
    ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_void,
                                               arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
pub type t_gotfn4 =
    ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_void,
                                               arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void,
                                               arg4:
                                                   *mut ::std::os::raw::c_void)>;
pub type t_gotfn5 =
    ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_void,
                                               arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void,
                                               arg4:
                                                   *mut ::std::os::raw::c_void,
                                               arg5:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn obj_list(x: *mut t_object, s: *mut t_symbol,
                    argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn pd_newest() -> *mut t_pd;
}
extern "C" {
    pub fn getbytes(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn getzbytes(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn copybytes(src: *mut ::std::os::raw::c_void, nbytes: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn freebytes(x: *mut ::std::os::raw::c_void, nbytes: usize);
}
extern "C" {
    pub fn resizebytes(x: *mut ::std::os::raw::c_void, oldsize: usize,
                       newsize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn atom_getfloat(a: *mut t_atom) -> t_float;
}
extern "C" {
    pub fn atom_getint(a: *mut t_atom) -> t_int;
}
extern "C" {
    pub fn atom_getsymbol(a: *mut t_atom) -> *mut t_symbol;
}
extern "C" {
    pub fn atom_gensym(a: *mut t_atom) -> *mut t_symbol;
}
extern "C" {
    pub fn atom_getfloatarg(which: ::std::os::raw::c_int,
                            argc: ::std::os::raw::c_int, argv: *mut t_atom)
     -> t_float;
}
extern "C" {
    pub fn atom_getintarg(which: ::std::os::raw::c_int,
                          argc: ::std::os::raw::c_int, argv: *mut t_atom)
     -> t_int;
}
extern "C" {
    pub fn atom_getsymbolarg(which: ::std::os::raw::c_int,
                             argc: ::std::os::raw::c_int, argv: *mut t_atom)
     -> *mut t_symbol;
}
extern "C" {
    pub fn atom_string(a: *mut t_atom, buf: *mut ::std::os::raw::c_char,
                       bufsize: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn binbuf_new() -> *mut _binbuf;
}
extern "C" {
    pub fn binbuf_free(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_duplicate(y: *mut _binbuf) -> *mut _binbuf;
}
extern "C" {
    pub fn binbuf_text(x: *mut _binbuf, text: *mut ::std::os::raw::c_char,
                       size: usize);
}
extern "C" {
    pub fn binbuf_gettext(x: *mut _binbuf,
                          bufp: *mut *mut ::std::os::raw::c_char,
                          lengthp: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn binbuf_clear(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_add(x: *mut _binbuf, argc: ::std::os::raw::c_int,
                      argv: *mut t_atom);
}
extern "C" {
    pub fn binbuf_addv(x: *mut _binbuf,
                       fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn binbuf_addbinbuf(x: *mut _binbuf, y: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_addsemi(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_restore(x: *mut _binbuf, argc: ::std::os::raw::c_int,
                          argv: *mut t_atom);
}
extern "C" {
    pub fn binbuf_print(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_getnatom(x: *mut _binbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_getvec(x: *mut _binbuf) -> *mut t_atom;
}
extern "C" {
    pub fn binbuf_resize(x: *mut _binbuf, newsize: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_eval(x: *mut _binbuf, target: *mut t_pd,
                       argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn binbuf_read(b: *mut _binbuf, filename: *mut ::std::os::raw::c_char,
                       dirname: *mut ::std::os::raw::c_char,
                       crflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_read_via_canvas(b: *mut _binbuf,
                                  filename: *mut ::std::os::raw::c_char,
                                  canvas: *mut _glist,
                                  crflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_read_via_path(b: *mut _binbuf,
                                filename: *mut ::std::os::raw::c_char,
                                dirname: *mut ::std::os::raw::c_char,
                                crflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_write(x: *mut _binbuf,
                        filename: *mut ::std::os::raw::c_char,
                        dir: *mut ::std::os::raw::c_char,
                        crflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_evalfile(name: *mut t_symbol, dir: *mut t_symbol);
}
extern "C" {
    pub fn binbuf_realizedollsym(s: *mut t_symbol, ac: ::std::os::raw::c_int,
                                 av: *mut t_atom,
                                 tonew: ::std::os::raw::c_int)
     -> *mut t_symbol;
}
extern "C" {
    pub fn clock_new(owner: *mut ::std::os::raw::c_void, fn_: t_method)
     -> *mut _clock;
}
extern "C" {
    pub fn clock_set(x: *mut _clock, systime: f64);
}
extern "C" {
    pub fn clock_delay(x: *mut _clock, delaytime: f64);
}
extern "C" {
    pub fn clock_unset(x: *mut _clock);
}
extern "C" {
    pub fn clock_setunit(x: *mut _clock, timeunit: f64,
                         sampflag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn clock_getlogicaltime() -> f64;
}
extern "C" {
    pub fn clock_getsystime() -> f64;
}
extern "C" {
    pub fn clock_gettimesince(prevsystime: f64) -> f64;
}
extern "C" {
    pub fn clock_gettimesincewithunits(prevsystime: f64, units: f64,
                                       sampflag: ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn clock_getsystimeafter(delaytime: f64) -> f64;
}
extern "C" {
    pub fn clock_free(x: *mut _clock);
}
extern "C" {
    pub fn pd_new(cls: *mut _class) -> *mut t_pd;
}
extern "C" {
    pub fn pd_free(x: *mut t_pd);
}
extern "C" {
    pub fn pd_bind(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_unbind(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_findbyclass(s: *mut t_symbol, c: *mut _class) -> *mut t_pd;
}
extern "C" {
    pub fn pd_pushsym(x: *mut t_pd);
}
extern "C" {
    pub fn pd_popsym(x: *mut t_pd);
}
extern "C" {
    pub fn pd_getfilename() -> *mut t_symbol;
}
extern "C" {
    pub fn pd_getdirname() -> *mut t_symbol;
}
extern "C" {
    pub fn pd_bang(x: *mut t_pd);
}
extern "C" {
    pub fn pd_pointer(x: *mut t_pd, gp: *mut t_gpointer);
}
extern "C" {
    pub fn pd_float(x: *mut t_pd, f: t_float);
}
extern "C" {
    pub fn pd_symbol(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_list(x: *mut t_pd, s: *mut t_symbol,
                   argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn pd_anything(x: *mut t_pd, s: *mut t_symbol,
                       argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn gpointer_init(gp: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_copy(gpfrom: *const t_gpointer, gpto: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_unset(gp: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_check(gp: *const t_gpointer,
                          headok: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inlet_new(owner: *mut t_object, dest: *mut t_pd, s1: *mut t_symbol,
                     s2: *mut t_symbol) -> *mut _inlet;
}
extern "C" {
    pub fn pointerinlet_new(owner: *mut t_object, gp: *mut t_gpointer)
     -> *mut _inlet;
}
extern "C" {
    pub fn floatinlet_new(owner: *mut t_object, fp: *mut t_float)
     -> *mut _inlet;
}
extern "C" {
    pub fn symbolinlet_new(owner: *mut t_object, sp: *mut *mut t_symbol)
     -> *mut _inlet;
}
extern "C" {
    pub fn signalinlet_new(owner: *mut t_object, f: t_float) -> *mut _inlet;
}
extern "C" {
    pub fn inlet_free(x: *mut _inlet);
}
extern "C" {
    pub fn outlet_new(owner: *mut t_object, s: *mut t_symbol) -> *mut _outlet;
}
extern "C" {
    pub fn outlet_bang(x: *mut _outlet);
}
extern "C" {
    pub fn outlet_pointer(x: *mut _outlet, gp: *mut t_gpointer);
}
extern "C" {
    pub fn outlet_float(x: *mut _outlet, f: t_float);
}
extern "C" {
    pub fn outlet_symbol(x: *mut _outlet, s: *mut t_symbol);
}
extern "C" {
    pub fn outlet_list(x: *mut _outlet, s: *mut t_symbol,
                       argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn outlet_anything(x: *mut _outlet, s: *mut t_symbol,
                           argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn outlet_getsymbol(x: *mut _outlet) -> *mut t_symbol;
}
extern "C" {
    pub fn outlet_free(x: *mut _outlet);
}
extern "C" {
    pub fn pd_checkobject(x: *mut t_pd) -> *mut t_object;
}
extern "C" {
    pub fn glob_setfilename(dummy: *mut ::std::os::raw::c_void,
                            name: *mut t_symbol, dir: *mut t_symbol);
}
extern "C" {
    pub fn canvas_setargs(argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn canvas_getargs(argcp: *mut ::std::os::raw::c_int,
                          argvp: *mut *mut t_atom);
}
extern "C" {
    pub fn canvas_getcurrentdir() -> *mut t_symbol;
}
extern "C" {
    pub fn canvas_getcurrent() -> *mut _glist;
}
extern "C" {
    pub fn canvas_makefilename(c: *mut _glist,
                               file: *mut ::std::os::raw::c_char,
                               result: *mut ::std::os::raw::c_char,
                               resultsize: ::std::os::raw::c_int);
}
extern "C" {
    pub fn canvas_getdir(x: *mut _glist) -> *mut t_symbol;
}
extern "C" {
    #[link_name = "sys_font"]
    pub static mut sys_font: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "sys_fontweight"]
    pub static mut sys_fontweight: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn sys_zoomfontwidth(fontsize: ::std::os::raw::c_int,
                             zoom: ::std::os::raw::c_int,
                             worstcase: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_zoomfontheight(fontsize: ::std::os::raw::c_int,
                              zoom: ::std::os::raw::c_int,
                              worstcase: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fontwidth(fontsize: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fontheight(fontsize: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canvas_dataproperties(x: *mut _glist, sc: *mut t_scalar,
                                 b: *mut _binbuf);
}
extern "C" {
    pub fn canvas_open(x: *mut _glist, name: *const ::std::os::raw::c_char,
                       ext: *const ::std::os::raw::c_char,
                       dirresult: *mut ::std::os::raw::c_char,
                       nameresult: *mut *mut ::std::os::raw::c_char,
                       size: ::std::os::raw::c_uint,
                       bin: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _widgetbehavior {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _parentwidgetbehavior {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pd_getparentwidget(x: *mut t_pd) -> *mut _parentwidgetbehavior;
}
extern "C" {
    pub fn class_new(name: *mut t_symbol, newmethod: t_newmethod,
                     freemethod: t_method, size: usize,
                     flags: ::std::os::raw::c_int, arg1: t_atomtype, ...)
     -> *mut _class;
}
extern "C" {
    pub fn class_addcreator(newmethod: t_newmethod, s: *mut t_symbol,
                            type1: t_atomtype, ...);
}
extern "C" {
    pub fn class_addmethod(c: *mut _class, fn_: t_method, sel: *mut t_symbol,
                           arg1: t_atomtype, ...);
}
extern "C" {
    pub fn class_addbang(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addpointer(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_doaddfloat(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addsymbol(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addlist(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addanything(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_sethelpsymbol(c: *mut _class, s: *mut t_symbol);
}
extern "C" {
    pub fn class_setwidget(c: *mut _class, w: *mut _widgetbehavior);
}
extern "C" {
    pub fn class_setparentwidget(c: *mut _class,
                                 w: *mut _parentwidgetbehavior);
}
extern "C" {
    pub fn class_parentwidget(c: *mut _class) -> *mut _parentwidgetbehavior;
}
extern "C" {
    pub fn class_getname(c: *mut _class) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_gethelpname(c: *mut _class) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_gethelpdir(c: *mut _class) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_setdrawcommand(c: *mut _class);
}
extern "C" {
    pub fn class_isdrawcommand(c: *mut _class) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn class_domainsignalin(c: *mut _class, onset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn class_set_extern_dir(s: *mut t_symbol);
}
pub type t_savefn =
    ::std::option::Option<unsafe extern "C" fn(x: *mut t_gobj,
                                               b: *mut _binbuf)>;
extern "C" {
    pub fn class_setsavefn(c: *mut _class, f: t_savefn);
}
extern "C" {
    pub fn class_getsavefn(c: *mut _class) -> t_savefn;
}
extern "C" {
    pub fn obj_saveformat(x: *mut t_object, bb: *mut _binbuf);
}
pub type t_propertiesfn =
    ::std::option::Option<unsafe extern "C" fn(x: *mut t_gobj,
                                               glist: *mut _glist)>;
extern "C" {
    pub fn class_setpropertiesfn(c: *mut _class, f: t_propertiesfn);
}
extern "C" {
    pub fn class_getpropertiesfn(c: *mut _class) -> t_propertiesfn;
}
extern "C" {
    pub fn post(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn startpost(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn poststring(s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn postfloat(f: t_floatarg);
}
extern "C" {
    pub fn postatom(argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn endpost();
}
extern "C" {
    pub fn error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn verbose(level: ::std::os::raw::c_int,
                   fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn bug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn pd_error(object: *mut ::std::os::raw::c_void,
                    fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn logpost(object: *const ::std::os::raw::c_void,
                   level: ::std::os::raw::c_int,
                   fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sys_logerror(object: *const ::std::os::raw::c_char,
                        s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_unixerror(object: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_ouch();
}
extern "C" {
    pub fn sys_isreadablefile(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_isabsolutepath(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_bashfilename(from: *const ::std::os::raw::c_char,
                            to: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_unbashfilename(from: *const ::std::os::raw::c_char,
                              to: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn open_via_path(dir: *const ::std::os::raw::c_char,
                         name: *const ::std::os::raw::c_char,
                         ext: *const ::std::os::raw::c_char,
                         dirresult: *mut ::std::os::raw::c_char,
                         nameresult: *mut *mut ::std::os::raw::c_char,
                         size: ::std::os::raw::c_uint,
                         bin: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_geteventno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_getrealtime() -> f64;
}
extern "C" {
    #[link_name = "sys_idlehook"]
    pub static mut sys_idlehook:
               ::std::option::Option<unsafe extern "C" fn()
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn sys_open(path: *const ::std::os::raw::c_char,
                    oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fopen(filename: *const ::std::os::raw::c_char,
                     mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sys_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_lock();
}
extern "C" {
    pub fn sys_unlock();
}
extern "C" {
    pub fn sys_trylock() -> ::std::os::raw::c_int;
}
pub type t_sample = f32;
#[repr(C)]
#[derive(Copy)]
pub union _sampleint_union {
    pub f: t_sample,
    pub i: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__sampleint_union() {
    assert_eq!(::std::mem::size_of::<_sampleint_union>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _sampleint_union ) ));
    assert_eq! (::std::mem::align_of::<_sampleint_union>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _sampleint_union ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _sampleint_union ) ) . f as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _sampleint_union ) ,
                "::" , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _sampleint_union ) ) . i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _sampleint_union ) ,
                "::" , stringify ! ( i ) ));
}
impl Clone for _sampleint_union {
    fn clone(&self) -> Self { *self }
}
pub type t_sampleint_union = _sampleint_union;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _signal {
    pub s_n: ::std::os::raw::c_int,
    pub s_vec: *mut t_sample,
    pub s_sr: t_float,
    pub s_refcount: ::std::os::raw::c_int,
    pub s_isborrowed: ::std::os::raw::c_int,
    pub s_borrowedfrom: *mut _signal,
    pub s_nextfree: *mut _signal,
    pub s_nextused: *mut _signal,
    pub s_vecsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__signal() {
    assert_eq!(::std::mem::size_of::<_signal>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _signal ) ));
    assert_eq! (::std::mem::align_of::<_signal>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _signal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_n as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_vec as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_vec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_sr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_sr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_refcount as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_isborrowed as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_isborrowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_borrowedfrom as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_borrowedfrom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_nextfree as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_nextfree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_nextused as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_nextused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _signal ) ) . s_vecsize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _signal ) , "::" ,
                stringify ! ( s_vecsize ) ));
}
impl Clone for _signal {
    fn clone(&self) -> Self { *self }
}
pub type t_signal = _signal;
pub type t_perfroutine =
    ::std::option::Option<unsafe extern "C" fn(args: *mut t_int)
                              -> *mut t_int>;
extern "C" {
    pub fn plus_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn zero_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn copy_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn dsp_add_plus(in1: *mut t_sample, in2: *mut t_sample,
                        out: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dsp_add_copy(in_: *mut t_sample, out: *mut t_sample,
                        n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dsp_add_scalarcopy(in_: *mut t_float, out: *mut t_sample,
                              n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dsp_add_zero(out: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sys_getblksize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_getsr() -> t_float;
}
extern "C" {
    pub fn sys_get_inchannels() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_get_outchannels() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsp_add(f: t_perfroutine, n: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn dsp_addv(f: t_perfroutine, n: ::std::os::raw::c_int,
                    vec: *mut t_int);
}
extern "C" {
    pub fn pd_fft(buf: *mut t_float, npoints: ::std::os::raw::c_int,
                  inverse: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ilog2(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mayer_fht(fz: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mayer_fft(n: ::std::os::raw::c_int, real: *mut t_sample,
                     imag: *mut t_sample);
}
extern "C" {
    pub fn mayer_ifft(n: ::std::os::raw::c_int, real: *mut t_sample,
                      imag: *mut t_sample);
}
extern "C" {
    pub fn mayer_realfft(n: ::std::os::raw::c_int, real: *mut t_sample);
}
extern "C" {
    pub fn mayer_realifft(n: ::std::os::raw::c_int, real: *mut t_sample);
}
extern "C" {
    #[link_name = "cos_table"]
    pub static mut cos_table: *mut f32;
}
extern "C" {
    pub fn canvas_suspend_dsp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canvas_resume_dsp(oldstate: ::std::os::raw::c_int);
}
extern "C" {
    pub fn canvas_update_dsp();
}
extern "C" {
    #[link_name = "canvas_dspstate"]
    pub static mut canvas_dspstate: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _resample {
    pub method: ::std::os::raw::c_int,
    pub downsample: ::std::os::raw::c_int,
    pub upsample: ::std::os::raw::c_int,
    pub s_vec: *mut t_sample,
    pub s_n: ::std::os::raw::c_int,
    pub coeffs: *mut t_sample,
    pub coefsize: ::std::os::raw::c_int,
    pub buffer: *mut t_sample,
    pub bufsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__resample() {
    assert_eq!(::std::mem::size_of::<_resample>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _resample ) ));
    assert_eq! (::std::mem::align_of::<_resample>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _resample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . method as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . downsample as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( downsample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . upsample as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( upsample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . s_vec as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( s_vec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . s_n as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( s_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . coeffs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( coeffs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . coefsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( coefsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . buffer as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _resample ) ) . bufsize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _resample ) , "::" ,
                stringify ! ( bufsize ) ));
}
impl Clone for _resample {
    fn clone(&self) -> Self { *self }
}
pub type t_resample = _resample;
extern "C" {
    pub fn resample_init(x: *mut t_resample);
}
extern "C" {
    pub fn resample_free(x: *mut t_resample);
}
extern "C" {
    pub fn resample_dsp(x: *mut t_resample, in_: *mut t_sample,
                        insize: ::std::os::raw::c_int, out: *mut t_sample,
                        outsize: ::std::os::raw::c_int,
                        method: ::std::os::raw::c_int);
}
extern "C" {
    pub fn resamplefrom_dsp(x: *mut t_resample, in_: *mut t_sample,
                            insize: ::std::os::raw::c_int,
                            outsize: ::std::os::raw::c_int,
                            method: ::std::os::raw::c_int);
}
extern "C" {
    pub fn resampleto_dsp(x: *mut t_resample, out: *mut t_sample,
                          insize: ::std::os::raw::c_int,
                          outsize: ::std::os::raw::c_int,
                          method: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mtof(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn ftom(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn rmstodb(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn powtodb(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn dbtorms(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn dbtopow(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn q8_sqrt(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn q8_rsqrt(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn qsqrt(arg1: t_float) -> t_float;
}
extern "C" {
    pub fn qrsqrt(arg1: t_float) -> t_float;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _garray {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "garray_class"]
    pub static mut garray_class: *mut _class;
}
extern "C" {
    pub fn garray_getfloatarray(x: *mut _garray,
                                size: *mut ::std::os::raw::c_int,
                                vec: *mut *mut t_float)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_getfloatwords(x: *mut _garray,
                                size: *mut ::std::os::raw::c_int,
                                vec: *mut *mut t_word)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_redraw(x: *mut _garray);
}
extern "C" {
    pub fn garray_npoints(x: *mut _garray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_vec(x: *mut _garray) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn garray_resize(x: *mut _garray, f: t_floatarg);
}
extern "C" {
    pub fn garray_resize_long(x: *mut _garray, n: ::std::os::raw::c_long);
}
extern "C" {
    pub fn garray_usedindsp(x: *mut _garray);
}
extern "C" {
    pub fn garray_setsaveit(x: *mut _garray, saveit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn garray_getglist(x: *mut _garray) -> *mut _glist;
}
extern "C" {
    pub fn garray_getarray(x: *mut _garray) -> *mut _array;
}
extern "C" {
    #[link_name = "scalar_class"]
    pub static mut scalar_class: *mut _class;
}
extern "C" {
    pub fn value_get(s: *mut t_symbol) -> *mut t_float;
}
extern "C" {
    pub fn value_release(s: *mut t_symbol);
}
extern "C" {
    pub fn value_getfloat(s: *mut t_symbol, f: *mut t_float)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn value_setfloat(s: *mut t_symbol, f: t_float)
     -> ::std::os::raw::c_int;
}
pub type t_guicallbackfn =
    ::std::option::Option<unsafe extern "C" fn(client: *mut t_gobj,
                                               glist: *mut _glist)>;
extern "C" {
    pub fn sys_vgui(fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sys_gui(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_pretendguibytes(n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sys_queuegui(client: *mut ::std::os::raw::c_void,
                        glist: *mut _glist, f: t_guicallbackfn);
}
extern "C" {
    pub fn sys_unqueuegui(client: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gfxstub_new(owner: *mut t_pd, key: *mut ::std::os::raw::c_void,
                       cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gfxstub_deleteforkey(key: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "glob_pdobject"]
    pub static mut glob_pdobject: *mut _class;
}
pub type t_externclass = *mut _class;
extern "C" {
    pub fn c_extern(cls: *mut t_externclass, newroutine: t_newmethod,
                    freeroutine: t_method, name: *mut t_symbol, size: usize,
                    tiny: ::std::os::raw::c_int, arg1: t_atomtype, ...);
}
extern "C" {
    pub fn c_addmess(fn_: t_method, sel: *mut t_symbol,
                     arg1: t_atomtype, ...);
}
#[repr(C)]
#[derive(Copy)]
pub union t_bigorsmall32 {
    pub f: t_float,
    pub ui: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_t_bigorsmall32() {
    assert_eq!(::std::mem::size_of::<t_bigorsmall32>() , 4usize , concat ! (
               "Size of: " , stringify ! ( t_bigorsmall32 ) ));
    assert_eq! (::std::mem::align_of::<t_bigorsmall32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_bigorsmall32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_bigorsmall32 ) ) . f as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_bigorsmall32 ) , "::"
                , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_bigorsmall32 ) ) . ui as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_bigorsmall32 ) , "::"
                , stringify ! ( ui ) ));
}
impl Clone for t_bigorsmall32 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sys_getversion(major: *mut ::std::os::raw::c_int,
                          minor: *mut ::std::os::raw::c_int,
                          bugfix: *mut ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pdinstance {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pdinstance_new() -> *mut _pdinstance;
}
extern "C" {
    pub fn pd_setinstance(x: *mut _pdinstance);
}
extern "C" {
    pub fn pdinstance_free(x: *mut _pdinstance);
}
extern "C" {
    pub fn pd_getcanvaslist() -> *mut _glist;
}
extern "C" {
    pub fn pd_getdspstate() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
